// This header file was auto-generated by ClassMate++
// Created: 30 Sep 2021 7:59:04 am
// Copyright (c) 2021, HurleyWorks

#pragma once

#include <nanogui/screen.h>

using OpenglWindowHandle = std::unique_ptr<class OpenglRenderer>;

struct GLFWwindow;

// This C++ class named "OpenglRenderer" provides a simple interface for managing an OpenGL window.
// The class includes the header file "OpenglRenderer.h" and two other header files : "berserkpch.h" and <GLFW / glfw3.h>.

// The class has a constructor that initializes the private member variables window and screen.
// It does this by iterating through a global map called __nanogui_screens, which contains a list
// of all the screens in the application.The window and screen pointers are set to the first entry 
// in this map.It is important to note that this class assumes that there is only one screen in the application.

// The class has three public methods : isOpen(), wait(), and refresh().isOpen()
// checks if the window should be closed, wait() blocks the current thread until an event occurs,
// and refresh() redraws the screen and posts an empty event to the event queue.

// This class relies on the GLFW library to create and manage the OpenGL window.
// Overall, this class provides a simple interface for managing an OpenGL window, 
// but it may not be suitable for more complex applications with multiple screens or windows.

class OpenglRenderer
{
public:
	static OpenglWindowHandle create() { return std::make_unique<OpenglRenderer>(); }

public:
	OpenglRenderer();
	~OpenglRenderer() = default;

	// Returns the nanogui screen object
	nanogui::Screen* getScreen() { return screen; }

	// Returns whether the window is open or not
	bool isOpen();

	// Renders the window by drawing all the elements on the screen
	void render() { screen->draw_all(); }

	// Calls glfwWaitEvents()
	void wait();

	// Refreshes the window
	void refresh();

private:
	nanogui::Screen* screen = nullptr;
	GLFWwindow* window = nullptr;

}; // end class OpenglRenderer
